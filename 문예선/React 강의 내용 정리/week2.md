## Components와 Props

### 1. 정의

#### 컴포넌트

- 리액트: 컴포넌트 기반 구조. 모든 페이지가 컴포넌트로 구성됨.
- 하나의 컴포넌트는 또 다른 여러 개의 컴포넌트의 조합으로 구성 가능.
- 레고 블록처럼 조립해 새로운 컴포넌트 생성 가능

- 컴포넌트는 개념적으로 자바스크립트 함수와 유사.

  | 입력(Props) → React Component → 출력(React Element)

- 리액트 엘리먼트: 리액트 앱을 구성하는 가장 작은 블록

  ##### 컴포넌트의 장점

  1. 하나의 컴포넌트를 반복적 사용. 개발 시간과 유지보수 비용 감소.

#### Props

- 리액트 컴포넌트의 속성

  ##### 붕어빵 비유

  - 컴포넌트 = 붕어빵 틀

  - Props = 붕어빵의 속재료

  - 엘리먼트 = 완성된 붕어빵

  > 즉 Props = 컴포넌트에 전달할 다양한 정보를 담고 있는 자바스크립트 객체.

### 2. Props의 특징 및 사용법

#### Props의 특징

- Read-Only(읽기 전용): 값을 변경 불가

  - 이유: 엘리먼트 생성 과정에서 값이 바뀌면 제대로 생성 불가.
  - Props를 바꾸려면 새로운 값을 컴포넌트에 전달하여 새로운 엘리먼트를 생성해야 함. 이 과정에서 엘리먼트가 다시 렌더링됨.

  ##### 자바스크립트 함수의 속성

  - 함수가 pure하다

    1.  입력값을 변경x.
    2.  같은 입력값에 대해서는 항상 같은 출력값을 리턴

  - 리액트 컴포넌트도 마찬가지여야 함.
    1.  Props를 직접 수정하지 않기
    2.  같은 Props에 대해 항상 같은 결과

#### Props 사용법

1. JSx 사용: 키와 값으로 이루어진 키, 값 쌍의 형태

- 속성값으로 문자열 외에 다른 것은 자바스크립트 표현식으로, {}로로 사용

2. JSx 사용x: creatElement에 {}와 자바스크립트 사용

### 3. Component 만들기 및 렌더링

#### 컴포넌트 생성 방법

1.  함수형 컴포넌트: JavaScript 함수를 사용해 컴포넌트 정의

2.  클래스형 컴포넌트: ES6 클래스를 사용하여 컴포넌트를 정의

- 컴포넌트 이름 짓기: 대문자로 시작.

  - 소문자로 시작하는 엘리먼트는 DOM 태그로 인식

#### 컴포넌트 렌더링

- ReactDOM.render() 함수 사용

### 4. Component 합성과 추출

#### 컴포넌트 합성

- 여러 개의 컴포넌트를 합쳐서 하나의 컴포넌트를 만드는 것.

  - 리액트에선 컴포넌트 안에 또 다른 컴포넌트 사용 가능.

  - 복잡한 화면을 여러 개의 컴포넌트로 나눠서 구현 가능

    ##### 예제

    ```jsx
    function Welcome(props) {
      return <h1>Hello, {props.name}</h1>;
    }

    function App(props) {
      return (
        <div>
          <Welcome name="Mike" />
          <Welcome name="Steve" />
          <Welcome name="Jane" />
        </div>
      );
    }

    ReactDOM.render(<App />, document.getElementById("root"));
    ```

    - App 컴포넌트가 Welcome 컴포넌트 세 개 포함

    - 각각의 Welcome 컴포넌트는 각기 다른 props를 가짐

    - App 컴포넌트를 루트로 하여 하위 컴포넌트들이 존재하는 형태 = 리액트로 구성된 앱의 기본적인 구조!

#### 컴포넌트 추출

- 큰 컴포넌트를 더 작은 컴포넌트로 나누는 과정

- 재사용성(따라서 보편적 단어 사용), 개발 속도 향상

## State와 Lifecycle

### 1. 정의

#### State

- 리액트 컴포넌트의 변경 가능한 데이터
-
- 개발자가 직접 정의하는 값

- 자바스크립트 객체 형태로 존재

  ##### 주의사항

  1. 렌더링이나 데이터 흐름에 사용되는 값만 state에 포함시켜야 함

  2. 관련 없는 값을 state에 포함시키면 불필요한 재렌더링이 발생해 성능이 저하될 수 있음

  3. 렌더링과 무관한 값은 컴포넌트의 인스턴스 필드로 정의해야 함

  ##### State 사용 규칙:

  1. state는 직접 수정할 수 없음(하면 안 됨)

  2. 반드시 setState() 함수를 통해 간접적으로 변경해야 함

#### Lifecycle(생명주기)

- 리액트 컴포넌트의 생명주기

  ##### 생명주기 단계:

  1. 출생

     - 컴포넌트가 생성되는 시점

     - 컴포넌트의 생성자가 실행됨

     - 이후 컴포넌트가 렌더링되고, componentDidMount 함수가 호출됨

  2. 인생

     - 컴포넌트가 변화를 겪으며 여러 번 렌더링됨

     - 업데이트가 발생한한 경우

       1. props가 변경될 때
       2. setState() 함수 호출로 state가 변경될 때
       3. forceUpdate() 함수 호출로 강제 업데이트될 때

     - 렌더링 이후에 componentDidUpdate 함수 호출

  3. 사망 = Unmount

     - 컴포넌트가 사라지는 과정

     - 상위 컴포넌트가 현재 컴포넌트를 더 이상 화면에 표시하지 않을 때 발생

     - unmount 직전에 componentWillUnmount 함수가 호출됨

## Hooks

### 1. 개념과 useState, useEffect

#### Hooks의 개념

- 리액트의 state와 생명주기 기능에 **갈고리**를 걸어 원하는 시점에 정해진 함수를 실행되도록 만든 것
- Hooks를 사용하면 함수 컴포넌트에서도 클래스 컴포넌트의 기능을 모두 동일하게 구현 가능
- 모든 Hook의 이름은 "use"로 시작. (각 기능을 사용하겠다는 의미)

#### useState

- 함수형 컴포넌트에서 상태 관리를 가능하게 해주는 Hook
- 클래스 컴포넌트: 생성자에서 state를 정의하고 setState() 함수로 업데이트/ 함수형 컴포넌트: useState로 구현

#### useEffect

- side effect = 렌더링 직후 작업을 설정하는 Hook
- 컴포넌트의 생명주기와 관련된 작업을 처리 가능

### 2. useMemo, useCallback, useRef

#### useMemo

- 계산 결과를 메모이제이션(최적화: 함수 호출 값 저장)하여 불필요한 재계산을 방지하는 Hook
- 렌더링이 일어나는 동안 useMemo의 함수 실행
- 의존성 배열 사용해야함(아니면 매 랜더링마다 실행됨됨)

#### useCallback

- 함수를 메모이제이션하여 불필요한 함수 재생성을 방지하는 Hook

- 값이 아닌 함수를 반환: 즉, 변수가 변경될 때 사용됨.

- 자식 컴포넌트에 함수를 props로 전달할 때 유용(부모 컴포넌트가 렌더링 될 때마다 자식 컴포넌트가 재랜더링하는 것을 방지지)

#### useRef

- 레퍼런스(특정 컨포넌트에 접근 객체체) 사용 위함.

1. DOM을 선택하는 역할

2. 렌더링과 상관없이 바뀔 수 있는 로컬변수 활용

- 내부 데이터 변경되어도 알리지 않음.
- Callback ref: 자식 컴포넌트 변경되면 알림.

### 3. Hook의 규칙과 Custom Hook 만들기

#### Hook의 규칙

1. Hook은 무조건 최상위 레벨에서만 호출 = 렌더링 될 때마다 같은 순서로 호출.

   - React 함수 컴포넌트의 최상위 레벨에서만 사용

   - 반복문, 조건문 내부에서 Hook을 호출하면 안 됩니다

2. 리액트 함수 컴포넌트에서만 Hook을 호출

- eslint-plugin-react-hooks: Hook의 규칙을 따르도록 도와주는 플러그인

#### Custom Hook 만들기

- React의 Hook 기능을 재사용 가능한 로직으로 캡슐화한 함수.

- 이름은 "use"로 시작하도록 하여 Hook으로 인식되게 함.

- 내부에서 다른 React Hook(useState, useEffect, useReducer 등)을 호출하여 상태 관리나 부수 효과를 처리함.

- 여러 컴포넌트에서 중복된 로직을 피하고 코드의 가독성과 유지보수성을 향상

  ##### Custom Hook의 기본 구조:

  - 만드는 상황: 로직이 중복

  - 이름이 use로 시작, 내부에서 다른 hook 호출.
  - 여러 개의 컴포넌트에서 hook 사용 -> state 공유하는 것 아님. (각각의 Custom Hook의 호출이 독립적)

### 1. Event의 정의 및 Event 다루기

#### Event의 정의

- 특정 사건
- 예: 사용자가 버튼을 클릭하는 사건 = 버튼 클릭 이벤트
- 이벤트 핸들링: 다양한 이벤트들이 발생했을 때 원하는 대로 처리하는 것

#### DOM과 React의 이벤트 처리 차이

##### 1. DOM에서의 이벤트 처리

- DOM에서 클릭 이벤트를 처리할 함수를 onclick을 통해 문자열로 전달

##### 2. React에서의 이벤트 처리

- React에선 이벤트 이름을 카멜 표기법으로 작성, 함수를 그대로 전달.

##### 3. 주요 차이점

- 표기법의 차이: React에서는 카멜 표기법.

- 함수 전달 방식의 차이: DOM에서는 문자열로 전달하지만, React에서는 함수 자체를 전달

#### Event Handler (Event Listener)

- 특정 이벤트가 발생했을 때 해당 이벤트를 처리하는 함수.

  - 이벤트를 계속 듣고 있다 = 이벤트 리스너

    1. 클래스 컴포넌트에서 이벤트 핸들러 정의

       - bind를 사용. 자바스크립트에서는 기본적으로 클래스 함수들이 바운드되지 않기 때문.

    2. 함수 컴포넌트에서 이벤트 핸들러 정의

       1. 함수 안에 함수로 정의

       2. 화살표 함수(arrow function)를 사용하여 정의

  ##### 이벤트 핸들러에 Arguments 전달하기

  - 이벤트 핸들러에 매개변수를 전달해야 하는 경우 존재.
    - 예: 특정 사용자 프로필을 클릭했을 때 해당 사용자의 아이디를 매개변수로 전달

  1.  클래스 컴포넌트에서 매개변수 전달

      1. 화살표 함수 사용
      2. bind 사용

      - 두 방법 모두 첫 번째 매개변수는 id이고, 두 번째 매개변수로 event가 전달됩니다.

  2.  함수 컴포넌트에서 매개변수 전달
